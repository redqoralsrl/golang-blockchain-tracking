// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0

package gen

import (
	"context"
	"database/sql"
	"fmt"
)

type DBTX interface {
	ExecContext(context.Context, string, ...interface{}) (sql.Result, error)
	PrepareContext(context.Context, string) (*sql.Stmt, error)
	QueryContext(context.Context, string, ...interface{}) (*sql.Rows, error)
	QueryRowContext(context.Context, string, ...interface{}) *sql.Row
}

func New(db DBTX) *Queries {
	return &Queries{db: db}
}

func Prepare(ctx context.Context, db DBTX) (*Queries, error) {
	q := Queries{db: db}
	var err error
	if q.createErc1155Stmt, err = db.PrepareContext(ctx, createErc1155); err != nil {
		return nil, fmt.Errorf("error preparing query CreateErc1155: %w", err)
	}
	if q.createErc721Stmt, err = db.PrepareContext(ctx, createErc721); err != nil {
		return nil, fmt.Errorf("error preparing query CreateErc721: %w", err)
	}
	if q.getBlockHeightStmt, err = db.PrepareContext(ctx, getBlockHeight); err != nil {
		return nil, fmt.Errorf("error preparing query GetBlockHeight: %w", err)
	}
	if q.insertBlockStmt, err = db.PrepareContext(ctx, insertBlock); err != nil {
		return nil, fmt.Errorf("error preparing query InsertBlock: %w", err)
	}
	if q.insertCoinLogStmt, err = db.PrepareContext(ctx, insertCoinLog); err != nil {
		return nil, fmt.Errorf("error preparing query InsertCoinLog: %w", err)
	}
	if q.insertContractStmt, err = db.PrepareContext(ctx, insertContract); err != nil {
		return nil, fmt.Errorf("error preparing query InsertContract: %w", err)
	}
	if q.insertERC1155LogStmt, err = db.PrepareContext(ctx, insertERC1155Log); err != nil {
		return nil, fmt.Errorf("error preparing query InsertERC1155Log: %w", err)
	}
	if q.insertERC20LogStmt, err = db.PrepareContext(ctx, insertERC20Log); err != nil {
		return nil, fmt.Errorf("error preparing query InsertERC20Log: %w", err)
	}
	if q.insertERC721LogStmt, err = db.PrepareContext(ctx, insertERC721Log); err != nil {
		return nil, fmt.Errorf("error preparing query InsertERC721Log: %w", err)
	}
	if q.insertLogStmt, err = db.PrepareContext(ctx, insertLog); err != nil {
		return nil, fmt.Errorf("error preparing query InsertLog: %w", err)
	}
	if q.insertTransactionStmt, err = db.PrepareContext(ctx, insertTransaction); err != nil {
		return nil, fmt.Errorf("error preparing query InsertTransaction: %w", err)
	}
	if q.insertWalletStmt, err = db.PrepareContext(ctx, insertWallet); err != nil {
		return nil, fmt.Errorf("error preparing query InsertWallet: %w", err)
	}
	if q.subtractERC1155BalanceStmt, err = db.PrepareContext(ctx, subtractERC1155Balance); err != nil {
		return nil, fmt.Errorf("error preparing query SubtractERC1155Balance: %w", err)
	}
	if q.updateContractTypeStmt, err = db.PrepareContext(ctx, updateContractType); err != nil {
		return nil, fmt.Errorf("error preparing query UpdateContractType: %w", err)
	}
	if q.upsertERC1155Balance_AddStmt, err = db.PrepareContext(ctx, upsertERC1155Balance_Add); err != nil {
		return nil, fmt.Errorf("error preparing query UpsertERC1155Balance_Add: %w", err)
	}
	if q.upsertERC20BalanceStmt, err = db.PrepareContext(ctx, upsertERC20Balance); err != nil {
		return nil, fmt.Errorf("error preparing query UpsertERC20Balance: %w", err)
	}
	if q.upsertERC721BalanceStmt, err = db.PrepareContext(ctx, upsertERC721Balance); err != nil {
		return nil, fmt.Errorf("error preparing query UpsertERC721Balance: %w", err)
	}
	if q.upsertWalletBalanceStmt, err = db.PrepareContext(ctx, upsertWalletBalance); err != nil {
		return nil, fmt.Errorf("error preparing query UpsertWalletBalance: %w", err)
	}
	return &q, nil
}

func (q *Queries) Close() error {
	var err error
	if q.createErc1155Stmt != nil {
		if cerr := q.createErc1155Stmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing createErc1155Stmt: %w", cerr)
		}
	}
	if q.createErc721Stmt != nil {
		if cerr := q.createErc721Stmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing createErc721Stmt: %w", cerr)
		}
	}
	if q.getBlockHeightStmt != nil {
		if cerr := q.getBlockHeightStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing getBlockHeightStmt: %w", cerr)
		}
	}
	if q.insertBlockStmt != nil {
		if cerr := q.insertBlockStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing insertBlockStmt: %w", cerr)
		}
	}
	if q.insertCoinLogStmt != nil {
		if cerr := q.insertCoinLogStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing insertCoinLogStmt: %w", cerr)
		}
	}
	if q.insertContractStmt != nil {
		if cerr := q.insertContractStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing insertContractStmt: %w", cerr)
		}
	}
	if q.insertERC1155LogStmt != nil {
		if cerr := q.insertERC1155LogStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing insertERC1155LogStmt: %w", cerr)
		}
	}
	if q.insertERC20LogStmt != nil {
		if cerr := q.insertERC20LogStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing insertERC20LogStmt: %w", cerr)
		}
	}
	if q.insertERC721LogStmt != nil {
		if cerr := q.insertERC721LogStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing insertERC721LogStmt: %w", cerr)
		}
	}
	if q.insertLogStmt != nil {
		if cerr := q.insertLogStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing insertLogStmt: %w", cerr)
		}
	}
	if q.insertTransactionStmt != nil {
		if cerr := q.insertTransactionStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing insertTransactionStmt: %w", cerr)
		}
	}
	if q.insertWalletStmt != nil {
		if cerr := q.insertWalletStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing insertWalletStmt: %w", cerr)
		}
	}
	if q.subtractERC1155BalanceStmt != nil {
		if cerr := q.subtractERC1155BalanceStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing subtractERC1155BalanceStmt: %w", cerr)
		}
	}
	if q.updateContractTypeStmt != nil {
		if cerr := q.updateContractTypeStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing updateContractTypeStmt: %w", cerr)
		}
	}
	if q.upsertERC1155Balance_AddStmt != nil {
		if cerr := q.upsertERC1155Balance_AddStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing upsertERC1155Balance_AddStmt: %w", cerr)
		}
	}
	if q.upsertERC20BalanceStmt != nil {
		if cerr := q.upsertERC20BalanceStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing upsertERC20BalanceStmt: %w", cerr)
		}
	}
	if q.upsertERC721BalanceStmt != nil {
		if cerr := q.upsertERC721BalanceStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing upsertERC721BalanceStmt: %w", cerr)
		}
	}
	if q.upsertWalletBalanceStmt != nil {
		if cerr := q.upsertWalletBalanceStmt.Close(); cerr != nil {
			err = fmt.Errorf("error closing upsertWalletBalanceStmt: %w", cerr)
		}
	}
	return err
}

func (q *Queries) exec(ctx context.Context, stmt *sql.Stmt, query string, args ...interface{}) (sql.Result, error) {
	switch {
	case stmt != nil && q.tx != nil:
		return q.tx.StmtContext(ctx, stmt).ExecContext(ctx, args...)
	case stmt != nil:
		return stmt.ExecContext(ctx, args...)
	default:
		return q.db.ExecContext(ctx, query, args...)
	}
}

func (q *Queries) query(ctx context.Context, stmt *sql.Stmt, query string, args ...interface{}) (*sql.Rows, error) {
	switch {
	case stmt != nil && q.tx != nil:
		return q.tx.StmtContext(ctx, stmt).QueryContext(ctx, args...)
	case stmt != nil:
		return stmt.QueryContext(ctx, args...)
	default:
		return q.db.QueryContext(ctx, query, args...)
	}
}

func (q *Queries) queryRow(ctx context.Context, stmt *sql.Stmt, query string, args ...interface{}) *sql.Row {
	switch {
	case stmt != nil && q.tx != nil:
		return q.tx.StmtContext(ctx, stmt).QueryRowContext(ctx, args...)
	case stmt != nil:
		return stmt.QueryRowContext(ctx, args...)
	default:
		return q.db.QueryRowContext(ctx, query, args...)
	}
}

type Queries struct {
	db                           DBTX
	tx                           *sql.Tx
	createErc1155Stmt            *sql.Stmt
	createErc721Stmt             *sql.Stmt
	getBlockHeightStmt           *sql.Stmt
	insertBlockStmt              *sql.Stmt
	insertCoinLogStmt            *sql.Stmt
	insertContractStmt           *sql.Stmt
	insertERC1155LogStmt         *sql.Stmt
	insertERC20LogStmt           *sql.Stmt
	insertERC721LogStmt          *sql.Stmt
	insertLogStmt                *sql.Stmt
	insertTransactionStmt        *sql.Stmt
	insertWalletStmt             *sql.Stmt
	subtractERC1155BalanceStmt   *sql.Stmt
	updateContractTypeStmt       *sql.Stmt
	upsertERC1155Balance_AddStmt *sql.Stmt
	upsertERC20BalanceStmt       *sql.Stmt
	upsertERC721BalanceStmt      *sql.Stmt
	upsertWalletBalanceStmt      *sql.Stmt
}

func (q *Queries) WithTx(tx *sql.Tx) *Queries {
	return &Queries{
		db:                           tx,
		tx:                           tx,
		createErc1155Stmt:            q.createErc1155Stmt,
		createErc721Stmt:             q.createErc721Stmt,
		getBlockHeightStmt:           q.getBlockHeightStmt,
		insertBlockStmt:              q.insertBlockStmt,
		insertCoinLogStmt:            q.insertCoinLogStmt,
		insertContractStmt:           q.insertContractStmt,
		insertERC1155LogStmt:         q.insertERC1155LogStmt,
		insertERC20LogStmt:           q.insertERC20LogStmt,
		insertERC721LogStmt:          q.insertERC721LogStmt,
		insertLogStmt:                q.insertLogStmt,
		insertTransactionStmt:        q.insertTransactionStmt,
		insertWalletStmt:             q.insertWalletStmt,
		subtractERC1155BalanceStmt:   q.subtractERC1155BalanceStmt,
		updateContractTypeStmt:       q.updateContractTypeStmt,
		upsertERC1155Balance_AddStmt: q.upsertERC1155Balance_AddStmt,
		upsertERC20BalanceStmt:       q.upsertERC20BalanceStmt,
		upsertERC721BalanceStmt:      q.upsertERC721BalanceStmt,
		upsertWalletBalanceStmt:      q.upsertWalletBalanceStmt,
	}
}
